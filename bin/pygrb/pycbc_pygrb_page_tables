#!/home/marco.cusinato/.conda/envs/pycbc_23_11/bin/python

# Copyright (C) 2021 Francesco Pannarale & Cameron Mills
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
Processes PyGRB triggers and injections to create html results tables.
"""

# =============================================================================
# Preamble
# =============================================================================
import sys
import os
import logging
import numpy as np
from scipy import stats
import h5py
import pycbc.version
from pycbc.detector import Detector
from pycbc import init_logging
import pycbc.results
from pycbc.results import pygrb_postprocessing_utils as ppu
try:
    from glue.ligolw import lsctables
except ImportError:
    pass

__author__ = "Francesco Pannarale <francesco.pannarale@ligo.org>"
__version__ = pycbc.version.git_verbose_msg
__date__ = pycbc.version.date
__program__ = "pycbc_pygrb_page_tables"

# =============================================================================
# Functions
# =============================================================================

def load_triggers(trig_file):
    """Function to load trigger file"""
    trigs = ppu.load_triggers(trig_file, None)
    data = {
        "end_time": trigs["/network/end_time_gc"][...],
        "ra": trigs["/network/ra"][...],
        "dec": trigs["/network/dec"][...],
        "coherent_snr": trigs["/network/coherent_snr"][...],
        "null_snr": trigs["/network/null_snr"][...],
        "reweighted_snr": trigs["/network/reweighted_snr"][...],
        "chisq": trigs["/network/my_network_chisq"][...],
        "time_slide_id": trigs["/network/slide_id"][...]
    }
    logging.info("%d triggers found.", len(data["end_time"]))
    return data

# =============================================================================
# Main script starts here
# =============================================================================
parser = ppu.pygrb_initialize_plot_parser(description=__doc__,
                                          version=__version__)
parser.add_argument("-F", "--offsource-file", action="store", required=True,
                    default=None, help="Location of off-source trigger file")
# As opposed to offsource-file and trig-file, this only contains onsource
parser.add_argument("--onsource-file", action="store", default=None,
                    help="Location of on-source trigger file.")
ppu.pygrb_add_injmc_opts(parser)
ppu.pygrb_add_bestnr_opts(parser)
parser.add_argument("--num-loudest-off-trigs", action="store",
                    type=int, default=30, help="Number of loudest " +
                    "offsouce triggers to output details about.")
parser.add_argument("--quiet-found-injs-output-file", default=None, #required=True,
                    help="Quiet-found injections html output file.")
parser.add_argument("--missed-found-injs-output-file", default=None, #required=True,
                    help="Missed-found injections html output file.")
parser.add_argument("--quiet-found-injs-h5-output-file", default=None, #required=True,
                    help="Quiet-found injections h5 output file.")
parser.add_argument("--loudest-offsource-trigs-output-file", default=None, #required=True,
                    help="Loudest offsource triggers html output file.")
parser.add_argument("--loudest-offsource-trigs-h5-output-file", default=None, #required=True,
                    help="Loudest offsource triggers h5 output file.")
parser.add_argument("--loudest-onsource-trig-output-file", default=None, #required=True,
                    help="Loudest onsource trigger html output file.")
parser.add_argument("--loudest-onsource-trig-h5-output-file", default=None, #required=True,
                    help="Loudest onsource trigger h5 output file.")
parser.add_argument("-g", "--glitch-check-factor", action="store",
                    type=float, default=1.0, help="When deciding " +
                    "exclusion efficiencies this value is multiplied " +
                    "to the offsource around the injection trigger to " +
                    "determine if it is just a loud glitch.")
parser.add_argument("-C", "--cluster-window", action="store", type=float,
                    default=0.1, help="The cluster window used " +
                    "to cluster triggers in time.")
opts = parser.parse_args()

init_logging(opts.verbose, format="%(asctime)s: %(levelname)s: %(message)s")
output_files = [opts.quiet_found_injs_output_file,
                opts.missed_found_injs_output_file,
                opts.quiet_found_injs_h5_output_file,
                opts.loudest_offsource_trigs_output_file,
                opts.loudest_offsource_trigs_h5_output_file,
                opts.loudest_onsource_trig_output_file,
                opts.loudest_onsource_trig_h5_output_file]
if output_files.count(None) == len(output_files):
    msg = "Please specify at least one output file location."
    parser.error(msg)

## COMMENTED UNTIL FOUND MISSED FILES
#if opts.quiet_found_injs_output_file or opts.missed_found_injs_output_file or\
#    opts.quiet_found_injs_h5_output_file:
#    do_injections = True
#    if (opts.found_file is None) and (opts.missed_file is None):
#        err_msg = "Must provide both found and missed injections file "
#        err_msg += "locations if processing injections."
#        parser.error(err_msg)
#else:
#    do_injections = False

if opts.loudest_onsource_trig_output_file or opts.loudest_onsource_trig_h5_output_file:
    if opts.onsource_file is None:
        err_msg = "Must provide the on-source file location to output its "
        err_msg += "loudest trigger information."
        parser.error(err_msg)

if not opts.newsnr_threshold:
    opts.newsnr_threshold = opts.snr_threshold

# Store options used multiple times in local variables
trig_file = opts.offsource_file
onsource_file = opts.onsource_file
#found_file = opts.found_file
#missed_file = opts.missed_file
chisq_index = opts.chisq_index
chisq_nhigh = opts.chisq_nhigh
wf_err = opts.waveform_error
cal_errs = {}
cal_errs['G1'] = opts.g1_cal_error
cal_errs['H1'] = opts.h1_cal_error
cal_errs['K1'] = opts.k1_cal_error
cal_errs['L1'] = opts.l1_cal_error
cal_errs['V1'] = opts.v1_cal_error
cal_dc_errs = {}
cal_dc_errs['G1'] = opts.g1_dc_cal_error
cal_dc_errs['H1'] = opts.h1_dc_cal_error
cal_dc_errs['K1'] = opts.k1_dc_cal_error
cal_dc_errs['L1'] = opts.l1_dc_cal_error
cal_dc_errs['V1'] = opts.v1_dc_cal_error
snr_thresh = opts.snr_threshold
sngl_snr_thresh = opts.sngl_snr_threshold
new_snr_thresh = opts.newsnr_threshold
null_grad_thresh = opts.null_grad_thresh
null_grad_val = opts.null_grad_val
null_thresh = list(map(float, opts.null_snr_threshold.split(',')))
upper_dist = opts.upper_inj_dist
lower_dist = opts.lower_inj_dist
num_bins = opts.num_bins
wav_err = opts.waveform_error
cluster_window = opts.cluster_window
glitch_check_fac = opts.glitch_check_factor
num_mc_injs = opts.num_mc_injections
qf_outfile = opts.quiet_found_injs_output_file
mf_outfile = opts.missed_found_injs_output_file
lofft_outfile = opts.loudest_offsource_trigs_output_file
lont_outfile = opts.loudest_onsource_trig_output_file
qf_h5_outfile = opts.quiet_found_injs_h5_output_file
lofft_h5_outfile = opts.loudest_offsource_trigs_h5_output_file
lont_h5_outfile = opts.loudest_onsource_trig_h5_output_file

# Set output directories
logging.info("Setting output directory.")
for output_file in output_files:
    if output_file:
        outdir = os.path.split(os.path.abspath(output_file))[0]
        if not os.path.isdir(outdir):
            os.makedirs(outdir)
            # Initialize random number generator
np.random.seed(opts.seed)
logging.info("Setting random seed to %d.", opts.seed)

# Extract IFOs and vetoes
print(opts.veto_category)
ifos, vetoes = ppu.extract_ifos_and_vetoes(trig_file, opts.veto_files,
                                           opts.veto_category)
# Load triggers, time-slides, and segment dictionary
logging.info("Loading triggers.")
trig_data = load_triggers(trig_file)
#print(trig_data)
logging.info("Loading timeslides.")
slide_dict = ppu.load_time_slides(trig_file)
logging.info("Loading segments.")
segment_dict = ppu.load_segment_dict(trig_file)
# Construct trials
logging.info("Constructing trials.")
trial_dict = ppu.construct_trials(opts.seg_files, segment_dict,
                                  ifos, slide_dict, vetoes)
total_trials = sum([len(trial_dict[slide_id]) for slide_id in slide_dict])
logging.info("%d trials generated.", total_trials)

# Extract basic trigger properties and store as dictionaries
trig_time, trig_snr, trig_bestnr = \
    ppu.extract_basic_trig_properties(trial_dict, trig_data, slide_dict, segment_dict, opts)
